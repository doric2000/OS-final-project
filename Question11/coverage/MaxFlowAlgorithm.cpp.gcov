        -:    0:Source:MaxFlowAlgorithm.cpp
        -:    0:Graph:./MaxFlowAlgorithm.gcno
        -:    0:Data:./MaxFlowAlgorithm.gcda
        -:    0:Runs:39
        -:    1:#include "MaxFlowAlgorithm.hpp"
        -:    2:#include <limits.h>
        -:    3:#include <queue>
        -:    4:#include <vector>
        -:    5:#include <string>
        -:    6:
       15:    7:std::string MaxFlowAlgorithm::run(const Graph::Graph& graph) {
       15:    8:    int n = graph.numOfVertices();
       60:    9:    std::vector<std::vector<int>> capacity(n, std::vector<int>(n, 0));
       75:   10:    for (int u = 0; u < n; ++u)
      380:   11:        for (int v = 0; v < n; ++v)
      320:   12:            capacity[u][v] = graph.getEdgeWeight(u, v);
       15:   13:    int flow = 0;
       30:   14:    std::vector<int> parent(n);
       37:   15:    auto bfs = [&](int s, int t) -> int {
       37:   16:        std::fill(parent.begin(), parent.end(), -1);
       37:   17:        parent[s] = -2;
       37:   18:        std::queue<std::pair<int, int>> q;
       37:   19:        q.push({s, INT_MAX});
       78:   20:        while (!q.empty()) {
       63:   21:            int u = q.front().first, f = q.front().second; q.pop();
      341:   22:            for (int v = 0; v < n; ++v) {
      300:   23:                if (parent[v] == -1 && capacity[u][v] > 0) {
       75:   24:                    parent[v] = u;
       75:   25:                    int new_f = std::min(f, capacity[u][v]);
       75:   26:                    if (v == t) return new_f;
       53:   27:                    q.push({v, new_f});
        -:   28:                }
        -:   29:            }
        -:   30:        }
       15:   31:        return 0;
       37:   32:    };
       15:   33:    int s = 0, t = n - 1;
        -:   34:    int new_flow;
        -:   35:    do {
       37:   36:        new_flow = bfs(s, t);
       37:   37:        if (new_flow) {
       22:   38:            flow += new_flow;
       22:   39:            int v = t;
       62:   40:            while (v != s) {
       40:   41:                int u = parent[v];
       40:   42:                capacity[u][v] -= new_flow;
       40:   43:                capacity[v][u] += new_flow;
       40:   44:                v = u;
        -:   45:            }
        -:   46:        }
       37:   47:    } while (new_flow);
       30:   48:    return "Max flow from 0 to n-1: " + std::to_string(flow);
       15:   49:}
