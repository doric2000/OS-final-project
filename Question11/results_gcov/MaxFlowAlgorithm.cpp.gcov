        -:    0:Source:MaxFlowAlgorithm.cpp
        -:    0:Graph:MaxFlowAlgorithm.gcno
        -:    0:Data:MaxFlowAlgorithm.gcda
        -:    0:Runs:55
        -:    1:#include "MaxFlowAlgorithm.hpp"
        -:    2:#include <limits.h>
        -:    3:#include <queue>
        -:    4:#include <vector>
        -:    5:#include <string>
        -:    6:
        4:    7:std::string MaxFlowAlgorithm::run(const Graph::Graph& graph) {
        4:    8:    int n = graph.numOfVertices();
       16:    9:    std::vector<std::vector<int>> capacity(n, std::vector<int>(n, 0));
       20:   10:    for (int u = 0; u < n; ++u)
       88:   11:        for (int v = 0; v < n; ++v)
       72:   12:            capacity[u][v] = graph.getEdgeWeight(u, v);
        4:   13:    int flow = 0;
        8:   14:    std::vector<int> parent(n);
       10:   15:    auto bfs = [&](int s, int t) -> int {
       10:   16:        std::fill(parent.begin(), parent.end(), -1);
       10:   17:        parent[s] = -2;
       10:   18:        std::queue<std::pair<int, int>> q;
       10:   19:        q.push({s, INT_MAX});
       30:   20:        while (!q.empty()) {
       26:   21:            int u = q.front().first, f = q.front().second; q.pop();
      154:   22:            for (int v = 0; v < n; ++v) {
      134:   23:                if (parent[v] == -1 && capacity[u][v] > 0) {
       25:   24:                    parent[v] = u;
       25:   25:                    int new_f = std::min(f, capacity[u][v]);
       25:   26:                    if (v == t) return new_f;
       19:   27:                    q.push({v, new_f});
        -:   28:                }
        -:   29:            }
        -:   30:        }
        4:   31:        return 0;
       10:   32:    };
        4:   33:    int s = 0, t = n - 1;
        -:   34:    int new_flow;
        -:   35:    do {
       10:   36:        new_flow = bfs(s, t);
       10:   37:        if (new_flow) {
        6:   38:            flow += new_flow;
        6:   39:            int v = t;
       21:   40:            while (v != s) {
       15:   41:                int u = parent[v];
       15:   42:                capacity[u][v] -= new_flow;
       15:   43:                capacity[v][u] += new_flow;
       15:   44:                v = u;
        -:   45:            }
        -:   46:        }
       10:   47:    } while (new_flow);
        8:   48:    return "Max flow from 0 to n-1: " + std::to_string(flow);
        4:   49:}
