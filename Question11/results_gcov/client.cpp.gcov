        -:    0:Source:client.cpp
        -:    1:/*
        -:    2:** client.cpp -- a stream socket client demo
        -:    3:*/
        -:    4:
        -:    5:#include <stdio.h>
        -:    6:#include <stdlib.h>
        -:    7:#include <unistd.h>
        -:    8:#include <errno.h>
        -:    9:#include <string.h>
        -:   10:#include <netdb.h>
        -:   11:#include <sys/types.h>
        -:   12:#include <netinet/in.h>
        -:   13:#include <sys/socket.h>
        -:   14:
        -:   15:#include <arpa/inet.h>
        -:   16:#include <vector>
        -:   17:#include <tuple>
        -:   18:#include "Graph.hpp"
        -:   19:#include <string>
        -:   20:#include <iostream>
        -:   21:#include <getopt.h>
        -:   22:#include <random>
        -:   23:#include <set>
        -:   24:#include <sstream>
        -:   25:
        -:   26:#define PORT "3490" // the port client will be connecting to 
        -:   27:
        -:   28:#define MAXDATASIZE 1000 // max number of bytes we can get at once 
        -:   29:
        -:   30:// get sockaddr, IPv4 or IPv6:
      102:   31:void *get_in_addr(struct sockaddr *sa)
        -:   32:{
      102:   33:	if (sa->sa_family == AF_INET) {
      102:   34:		return &(((struct sockaddr_in*)sa)->sin_addr);
        -:   35:	}
        -:   36:
    #####:   37:	return &(((struct sockaddr_in6*)sa)->sin6_addr);
        -:   38:}
        -:   39:
       59:   40:int main(int argc, char *argv[])
        -:   41:{
        -:   42:	int sockfd;
        -:   43:	struct addrinfo hints, *servinfo, *p;
        -:   44:	int rv;
        -:   45:	char s[INET6_ADDRSTRLEN];
        -:   46:
       59:   47:	const char* hostname = "127.0.0.1";
       59:   48:	memset(&hints, 0, sizeof hints);
       59:   49:	hints.ai_family = AF_UNSPEC;
       59:   50:	hints.ai_socktype = SOCK_STREAM;
        -:   51:
       59:   52:	int seed = time(NULL);
        -:   53:	// getopt setup
        -:   54:	int opt;
       59:   55:	int mode = -1; // -1=unset, 0=manual, 1=random
       59:   56:	int vertices = 0, edges = 0, max_weight = 10;
       59:   57:	bool error = false;
      336:   58:	while ((opt = getopt(argc, argv, "rmn:e:w:s:")) != -1) {
      277:   59:		switch (opt) {
       44:   60:			case 'r': mode = 1; break;
       17:   61:			case 'm': mode = 0; break;
       55:   62:			case 'n': vertices = atoi(optarg); break;
       53:   63:			case 'e': edges = atoi(optarg); break;
       53:   64:			case 'w': max_weight = atoi(optarg); break;
       54:   65:			case 's': seed = atoi(optarg); break;
        1:   66:			default: error = true; break;
        -:   67:		}
        -:   68:	}
       59:   69:	if (mode == -1 || vertices <= 0 || error || (mode == 1 && edges <= 0)) {
        8:   70:		fprintf(stderr,
        -:   71:			"Usage: %s [-r|-m] -n <vertices> -e <edges> [-w <max_weight>] [-s <seed>]\n"
        -:   72:			"  -r : random graph mode (requires -n, -e, -w) [-s <seed>]\n"
        -:   73:			"  -m : manual graph mode (requires -n, -e)\n"
        -:   74:			"  -n : number of vertices (>0)\n"
        -:   75:			"  -e : number of edges (>0)\n"
        -:   76:			"  -w : max edge weight (random mode, default 10)\n"
        -:   77:			"  -s : random seed (optional, random mode only, default is current time)\n",
        -:   78:			argv[0]);
        8:   79:		return 1;
        -:   80:	}
        -:   81:
       51:   82:	if ((rv = getaddrinfo(hostname, PORT, &hints, &servinfo)) != 0) {
    #####:   83:		fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(rv));
    #####:   84:		return 1;
        -:   85:	}
        -:   86:
      51*:   87:	for(p = servinfo; p != NULL; p = p->ai_next) {
      51*:   88:		if ((sockfd = socket(p->ai_family, p->ai_socktype,
       51:   89:				p->ai_protocol)) == -1) {
    #####:   90:			perror("client: socket");
    #####:   91:			continue;
        -:   92:		}
       51:   93:		inet_ntop(p->ai_family,
       51:   94:			get_in_addr((struct sockaddr *)p->ai_addr),
        -:   95:			s, sizeof s);
       51:   96:		printf("client: attempting connection to %s\n", s);
      51*:   97:		if (connect(sockfd, p->ai_addr, p->ai_addrlen) == -1) {
    #####:   98:			perror("client: connect");
    #####:   99:			close(sockfd);
    #####:  100:			continue;
        -:  101:		}
       51:  102:		break;
        -:  103:	}
        -:  104:
       51:  105:	if (p == NULL) {
    #####:  106:		fprintf(stderr, "client: failed to connect\n");
    #####:  107:		return 2;
        -:  108:	}
       51:  109:	inet_ntop(p->ai_family,
       51:  110:			get_in_addr((struct sockaddr *)p->ai_addr),
        -:  111:			s, sizeof s);
       51:  112:	printf("client: connected to %s\n", s);
       51:  113:	freeaddrinfo(servinfo);
        -:  114:
        -:  115:	// Build graph (always directed & weighted)
      102:  116:	std::vector<std::tuple<int,int,int>> edgeList;
       51:  117:	if (mode == 1) {
        -:  118:		// Random graph: generate 'edges' random directed edges with random weights
       39:  119:		if (edges <= 0 || edges > vertices * (vertices - 1)) {
        1:  120:			fprintf(stderr, "Error: Number of edges must be in [1, V*(V-1)] for directed graph without self-loops.\n");
        1:  121:			return 1;
        -:  122:		}
       38:  123:		std::mt19937 gen(seed);
       38:  124:		std::uniform_int_distribution<> weight_dist(1, max_weight);
       38:  125:		std::set<std::pair<int,int>> used_edges;
       38:  126:		int generated = 0;
      385:  127:		while (generated < edges) {
      347:  128:			int u = gen() % vertices;
      347:  129:			int v = gen() % vertices;
      394:  130:			if (u == v) continue; // No self-loops
      295:  131:			if (used_edges.count({u, v})) continue; // No duplicate edges
      248:  132:			int w = weight_dist(gen);
      248:  133:			edgeList.push_back(std::make_tuple(u, v, w));
      248:  134:			used_edges.insert({u, v});
      248:  135:			++generated;
        -:  136:		}
       38:  137:	} else {
        -:  138:		// Manual graph
       12:  139:		if (vertices <= 0) {
    #####:  140:			fprintf(stderr, "Error: Number of vertices must be positive in manual mode.\n");
    #####:  141:			return 1;
        -:  142:		}
       12:  143:		if (edges <= 0) {
        1:  144:			fprintf(stderr, "Error: Number of edges must be provided as a command-line argument (-e <edges>) in manual mode.\n");
        1:  145:			return 1;
        -:  146:		}
       15:  147:		for (int i = 0; i < edges; ++i) {
        -:  148:			int u, v, w;
       14:  149:			printf("Enter edge %d (u v w): ", i+1);
       14:  150:			if (scanf("%d %d %d", &u, &v, &w) != 3 || u < 0 || u >= vertices || v < 0 || v >= vertices || w <= 0) {
        8:  151:				fprintf(stderr, "Error: Invalid edge or weight.\n");
       10:  152:				return 1;
        -:  153:			}
        6:  154:			if (u == v) {
        1:  155:				fprintf(stderr, "Warning: Self-loops not allowed.\n");
        1:  156:				return 1;
        -:  157:			}
        5:  158:			bool duplicate = false;
        9:  159:			for (auto& e : edgeList) {
        4:  160:				if (std::get<0>(e) == u && std::get<1>(e) == v) duplicate = true;
        -:  161:			}
        5:  162:			if (duplicate) {
        1:  163:				fprintf(stderr, "Warning: Duplicate edge (%d,%d) not allowed.\n", u, v);
        1:  164:				return 1;
        -:  165:			}
        4:  166:			edgeList.push_back(std::make_tuple(u, v, w));
        -:  167:		}
        -:  168:	}
        -:  169:
        -:  170:	// Build one message with all parameters and edges
       78:  171:	std::ostringstream oss;
       39:  172:	oss << seed << "\n";
       39:  173:	int directed = 1; // Always directed graph
       39:  174:	oss << directed << "\n" << vertices << "\n" << edges << "\n";
      290:  175:	for (auto& e : edgeList) {
      251:  176:	    oss << std::get<0>(e) << " " << std::get<1>(e) << " " << std::get<2>(e) << "\n";
        -:  177:	}
       78:  178:	std::string graphData = oss.str();
       39:  179:	if (send(sockfd, graphData.c_str(), graphData.size(), 0) == -1) {
    #####:  180:		perror("send");
    #####:  181:		return 1;
        -:  182:	}
        -:  183:
        -:  184:	// Receive result from server
       39:  185:	char result[1024] = {0};
       39:  186:	recv(sockfd, result, sizeof(result), 0);
       39:  187:	std::cout << "Result from server: \n" << result << std::endl;
        -:  188:	// Finish
       39:  189:	close(sockfd);
       39:  190:	return 0;
        -:  191:}
